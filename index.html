<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>水墨碎片修復 - 橫式</title>
    <style>
        /* 強制全屏佈局 */
        body { 
            margin: 0; padding: 0; 
            display: flex; justify-content: center; align-items: center; 
            height: 100vh; width: 100vw; overflow: hidden; font-family: "Microsoft JhengHei", sans-serif;
            background-color: #1a1a1a; /* 螢幕最外層底色 */
        }

        #game-container { 
            position: relative; 
            height: 75vh; /* 高度佔螢幕 85% */
            aspect-ratio: 350 / 190; /* 寬度遠大於高度，營造左右留白效果 */
            
            /* 背景圖設定：置中且不重複 */
            background-image: url('bg.jpg'); 
            background-size: contain; 
            background-repeat: no-repeat; 
            background-position: center; 
            
            background-color: #ccc; /* 容器兩側露出的顏色 */
            border: 5px solid #ccc;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            overflow: visible;
        }

        /* 碎片樣式 */
        .piece { 
            position: absolute; 
            cursor: grab; 
            touch-action: none; 
            z-index: 10;
            filter: drop-shadow(0px 0px 0px rgba(0,0,0,0.5));
            transition: transform 0.2s;
        }

        .piece:active { 
            cursor: grabbing; 
            z-index: 100; 
            transform: scale(1); /*拼圖的放大縮小*/
        }

        .piece.locked { 
            z-index: 1; 
            pointer-events: none; 
            filter: none;
            transition: all 0.4s ease-out;
        }

        /* 完成後的覆蓋層 */
        #complete-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url('complete.jpg'); 
            background-size: contain; 
            background-repeat: no-repeat;
            background-position: center;
            z-index: 2000; display: none; opacity: 0; 
            transition: opacity 1.2s ease;
        }

        #message { position: fixed; bottom: 3%; color: white; background: rgba(0,0,0,0.6); padding: 10px 25px; border-radius: 30px; z-index: 1000; pointer-events: none; }
        
        #debug { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: #0f0; padding: 10px; font-size: 12px; z-index: 3000; pointer-events: none; border-radius: 5px; }
    </style>
</head>
<body>

    <div id="debug">對位模式 (橫式)</div>
    <div id="message">將碎片拖動至正確位置</div>

    <div id="game-container">
        <div id="complete-overlay"></div>
        
        <img src="piece1.png" id="p1" class="piece" style="width: 12.11%; left: 5%; top: 10%;" data-target-x="45.5" data-target-y="14.4">
        <img src="piece2.png" id="p2" class="piece" style="width: 11.13%; left: 3%; top: 35%;" data-target-x="50.1" data-target-y="33.7">
        <img src="piece3.png" id="p3" class="piece" style="width: 7.05%; left: 3%; top: 60%;" data-target-x="26.9" data-target-y="16">
        <img src="piece4.png" id="p4" class="piece" style="width: 9.07%; left: 4%; top: 80%;" data-target-x="38.2" data-target-y="39.85">
        
        <img src="piece5.png" id="p5" class="piece" style="width: 15.04%; left: 90%; top: 5%;" data-target-x="24.2" data-target-y="36.82">
        <img src="piece6.png" id="p6" class="piece" style="width: 9%; left: 90%; top: 25%;" data-target-x="39" data-target-y="63.1">
        <img src="piece7.png" id="p7" class="piece" style="width: 12%; left: 89%; top: 40%;" data-target-x="20" data-target-y="55.1">
        <img src="piece8.png" id="p8" class="piece" style="width: 8%; left: 92%; top: 65%;" data-target-x="58.2" data-target-y="66.7">
        <img src="piece9.png" id="p9" class="piece" style="width: 12.11%; left: 90%; top: 85%;" data-target-x="31.5" data-target-y="83.4">
    </div>

    <script>
        const container = document.getElementById('game-container');
        const debug = document.getElementById('debug');
        let activePiece = null;

        document.querySelectorAll('.piece').forEach(piece => {
            piece.onpointerdown = function(e) {
                if(piece.classList.contains('locked')) return;
                activePiece = piece;
                piece.setPointerCapture(e.pointerId);
            };

            piece.onpointermove = function(e) {
                if (!activePiece) return;
                const rect = container.getBoundingClientRect();
                
                // 計算相對位置百分比
                let x = ((e.clientX - rect.left) / rect.width) * 100;
                let y = ((e.clientY - rect.top) / rect.height) * 100;
                
                const pWidth = parseFloat(activePiece.style.width);
                const pHeight = (activePiece.offsetHeight / rect.height) * 100;

                // 讓滑鼠位於碎片中心
                activePiece.style.left = (x - pWidth/2) + '%';
                activePiece.style.top = (y - pHeight/2) + '%';

                // 更新 Debug 資訊
                debug.innerHTML = `正在移動: ${activePiece.id}<br>目標 X: ${activePiece.getAttribute('data-target-x')}%<br>目前 X: ${x.toFixed(1)}%<br>目前 Y: ${y.toFixed(1)}%`;
            };

            piece.onpointerup = function(e) {
                if (!activePiece) return;
                
                const rect = container.getBoundingClientRect();
                const pWidth = parseFloat(activePiece.style.width);
                const pHeight = (activePiece.offsetHeight / rect.height) * 100;

                const currentX = parseFloat(activePiece.style.left) + pWidth/2;
                const currentY = parseFloat(activePiece.style.top) + pHeight/2;
                
                const targetX = parseFloat(activePiece.getAttribute('data-target-x'));
                const targetY = parseFloat(activePiece.getAttribute('data-target-y'));

                // 計算中心點與目標點的距離
                const distance = Math.sqrt(Math.pow(currentX - targetX, 2) + Math.pow(currentY - targetY, 2));

                if (distance < 4.5) { // 磁吸範圍
                    activePiece.style.left = (targetX - pWidth/2) + '%';
                    activePiece.style.top = (targetY - pHeight/2) + '%';
                    activePiece.classList.add('locked');
                    checkWin();
                }
                activePiece = null;
            };
        });

        function checkWin() {
            const lockedCount = document.querySelectorAll('.piece.locked').length;
            if (lockedCount === 9) {
                const ov = document.getElementById('complete-overlay');
                ov.style.display = 'block';
                setTimeout(() => {
                    ov.style.opacity = '1';
                    document.getElementById('message').innerText = "修復完成！";
                }, 50);
            }
        }

        // 阻止移動端瀏覽器預設行為（如縮放或下拉刷新）
        document.addEventListener('touchmove', (e) => {
            if (e.target.classList.contains('piece')) e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>